{
  "hash": "49bab08d233ad10c4d975f90d59bb19f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Figures\njupyter:\n  jupytext:\n    text_representation:\n      extension: .qmd\n      format_name: quarto\n      format_version: '1.0'\n      jupytext_version: 1.16.2\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n---\n\n::: {#ff16d047 .cell execution_count=1}\n``` {}\nfrom fbm import FBM #fractional signals\nimport matplotlib.pyplot as plt #plotting\nimport matplotlib.lines as lines #draw lines\nfrom matplotlib.patches import Polygon\nimport numpy as np #numbers\nfrom sklearn.linear_model import LinearRegression #perform linear regression\nfrom scipy import signal #create signals\nimport string #for latex\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n```\n:::\n\n\n:::{#bb2a8a97 .cell .markdown}\n## Sierpinksi Triangle\n:::\n\n::: {#cell-fig-fractal .cell execution_count=2}\n``` {}\n#| label: fig-fractal\n#| fig-cap: |\n#| \n#| \n#| \n#|   **Ideal mathematical fractal.** The 2D Sierpinski triangle starts with a simple equilateral triangle (left), \n#| \n#|   and subdivides it recursively into smaller equilateral triangles. For every iteration, each triangle (in blue) \n#| \n#|   is further subdivided it into four smaller congruent equilateral triangles with the central triangle removed. \n#| \n#|   The first such iteration is shown in the centre, with the fifth iteration shown on the right.\ndef sierpinski_triangle(level, p1, p2, p3):\n    \"\"\"Generate the triangles for a Sierpinski triangle at the given iteration level.\"\"\"\n    if level == 0:\n        return [np.array([p1, p2, p3])]\n    \n    # Calculate midpoints\n    mid1 = (p1 + p2) / 2\n    mid2 = (p2 + p3) / 2\n    mid3 = (p3 + p1) / 2\n    \n    # Recursively generate triangles for each sub-triangle\n    triangles = []\n    triangles.extend(sierpinski_triangle(level-1, p1, mid1, mid3))\n    triangles.extend(sierpinski_triangle(level-1, mid1, p2, mid2))\n    triangles.extend(sierpinski_triangle(level-1, mid3, mid2, p3))\n    \n    return triangles\n\ndef plot_sierpinski(ax, level):\n    \"\"\"Plot a Sierpinski triangle on the given axes.\"\"\"\n    # Define the initial triangle points\n    height = np.sqrt(3) / 2\n    p1 = np.array([0, 0])\n    p2 = np.array([1, 0])\n    p3 = np.array([0.5, height])\n    \n    if level == 0:\n        # For level 0, just plot the single triangle\n        triangles = [np.array([p1, p2, p3])]\n    else:\n        # For level > 0, generate the Sierpinski triangles\n        triangles = sierpinski_triangle(level, p1, p2, p3)\n    \n    # Create and add polygon patches to the axes\n    for triangle in triangles:\n        # The Polygon constructor takes the vertices as its first argument\n        polygon = Polygon(triangle, closed=True, edgecolor='k', facecolor='cornflowerblue', linewidth=0.5)\n        ax.add_patch(polygon)\n    \n    # Set limits and title\n    ax.set_xlim([-0.1, 1.1])\n    ax.set_ylim([-0.1, height + 0.1])\n    ax.set_aspect('equal')\n    ax.set_axis_off()\n\n# Create figure and subplots\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\n# Level 0: Simple triangle\nplot_sierpinski(axes[0], 0)\n\n# Level 1: First Sierpinski iteration\nplot_sierpinski(axes[1], 1)\n\n# Level 5: Fifth Sierpinski iteration\nplot_sierpinski(axes[2], 5)\n\nplt.tight_layout()\nplt.savefig('../image/sierpinkski.png', dpi=600, bbox_inches='tight', format='png')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![\n\n\n\n\n\n\n**Ideal mathematical fractal.** The 2D Sierpinski triangle starts with a simple equilateral triangle (left), \n\n\n\nand subdivides it recursively into smaller equilateral triangles. For every iteration, each triangle (in blue) \n\n\n\nis further subdivided it into four smaller congruent equilateral triangles with the central triangle removed. \n\n\n\nThe first such iteration is shown in the centre, with the fifth iteration shown on the right.\n](Figures_files/figure-html/fig-fractal-output-1.png){#fig-fractal width=1430 height=429}\n:::\n:::\n\n\n:::{#1505fca0 .cell .markdown}\n## Exact vs Statistical Fractal\n:::\n\n::: {#5fe2d7db .cell execution_count=3}\n``` {}\ndef draw_fractal_tree(ax, x, y, length, angle, depth):\n    \"\"\"\n    Draw a self-similar fractal tree.\n    \n    Parameters:\n    - ax: Matplotlib axis\n    - x, y: Starting coordinates\n    - length: Branch length\n    - angle: Angle in radians\n    - depth: Recursion depth\n    \"\"\"\n    if depth == 0:\n        return\n    \n    # Calculate endpoint using trigonometry\n    x2 = x + length * np.sin(angle)\n    y2 = y + length * np.cos(angle)\n    \n    # Draw the branch\n    ax.plot([x, x2], [y, y2], 'k-', linewidth=0.8)\n    \n    # Left branch\n    left_angle = angle + np.pi/3\n    # Right branch\n    right_angle = angle - np.pi/3\n    \n    # Reduce length for next branches\n    new_length = length * 0.6\n    \n    # Recursively draw the branches\n    draw_fractal_tree(ax, x2, y2, new_length, left_angle, depth-1)\n    draw_fractal_tree(ax, x2, y2, new_length, right_angle, depth-1)\n\n# Create figure and axis\nfig, ax = plt.subplots(figsize=(10, 10))\n\n# Configure the axis\n#ax.set_xlim(-5, 5)\nax.set_ylim(0, 10)\nax.set_aspect('equal')\nax.axis('off')\n\n# Draw the tree starting from the bottom center\n# with initial upward direction (angle = 0)\ndraw_fractal_tree(ax, 0, 0, 4.7, 0, 10)\n\n# Ensure tight layout\n#plt.tight_layout()\nplt.savefig('../image/fractal_tree.png', dpi=600, bbox_inches='tight', format='png')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-4-output-1.png){width=763 height=579}\n:::\n:::\n\n\n:::{#b85d2a8c .cell .markdown}\n## Four Properties of Fractal Signals\n:::\n\n::: {#cell-fig-fourprop .cell execution_count=4}\n``` {}\n#| label: fig-fourprop\n#| fig-cap: |\n#| \n#| \n#| \n#|   **Main properties of a fractal time-series** A-C show a raw time-series (fractional Gaussian noise in this example)\n#| \n#|   at different scales: B is the first half of A (shown as vertical dashed lines in A), \n#| \n#|   while C is half of B (shown in vertical dashed lines in B). D is a power spectral density plot of A. \n#| \n#|   E shows D but on a log-log plot, demonstrating the linear nature of fractal signals when plotted on a log-log scale.\n#| \n#|   The slope of E is $-\\beta$. In this example, $\\beta$ is calculated to be 0.6, which translates to an H of 0.8.\n#| \n#|   F shows a modified version of E, which imagines that E only demonstrates a power law scaling relationship \n#| \n#|   between two distinct frequencies. The equation for calculating the scaling range in decades is shown.\n#| \n#|   Exact fractal time-series (A) was created using the Davies-Harte method.\nplt.rcParams['text.usetex'] = True #latex\n\nnp.random.seed(4)\nscale1=1024\nscale2=512\nscale3=256\n\nfp7 = FBM(scale1, hurst=0.8, length=1, method='daviesharte')\nfgnp7 = fp7.fgn()*100\n\nfig, ax = plt.subplots(3,2, constrained_layout=True, figsize=(8,8))\nax[0][0].plot(fgnp7)\nax[0][0].axvline(x=scale2, color='red', linestyle='--')\nax[0][0].axvline(x=0, color='red', linestyle='--')\nax[0][0].set_title(\"Raw time-series\", loc='left')\n\nax[1][0].plot(fgnp7[:scale2])\nax[1][0].axvline(x=scale3, color='red', linestyle='--')\nax[1][0].axvline(x=0, color='red', linestyle='--')\nax[1][0].set_ylabel('Signal Amplitude')\nax[1][0].set_title(\"Half of segment of A\", loc='left')\n\nax[2][0].plot(fgnp7[:scale3])\nax[2][0].set_xlabel('Time')\nax[2][0].set_title(\"Half of segment of B\", loc='left')\n\nfreq, power = signal.periodogram(fgnp7, 1)\npower = power[1:]\nfreq = freq[1:]\n\nlog_power = np.log10(power)\nlog_freq = np.log10(freq)\nlog_power = log_power[1:]\nlog_freq = log_freq[1:]\n\nmodel = LinearRegression().fit(log_freq.reshape(-1,1), log_power)\npredicted_power = 10**model.predict(log_freq.reshape(-1,1))\nHurst = (model.coef_*-1+1)/2\n\nax[0][1].plot(freq.reshape(-1,1), power)\nax[0][1].set_title(\"Power spectral density of A\", loc='left')\n\nax[1][1].plot(freq.reshape(-1,1), power)\nax[1][1].set_xscale('log')\nax[1][1].set_yscale('log')\nax[1][1].plot(freq[1:].reshape(-1,1), predicted_power, color='red')\nax[1][1].text(0.002, .01, r\"$\\beta=0.6$\", color=\"r\", fontsize=14)\nax[1][1].text(0.002, .002, r\"$H=0.8$\", color=\"r\", fontsize=14)\nax[1][1].set_title(\"Log-log plot of D\", loc='left')\nax[1][1].set_xlabel(r\"Frequency ($f$)\")\nax[1][1].set_ylabel(r\"Amplitude ($|A(f)|^{2}$)\")\n\nnewpower=power\nfp5 = FBM(scale1, hurst=0.5, length=1, method='daviesharte')\nfgnp5 = fp5.fgn()*5\np5freq, p5power = signal.periodogram(fgnp5, 1)\np5power=p5power - np.mean(p5power) + predicted_power[-1]*1.4\nnewpower[:10]= (np.random.rand(10)+0.5) # 10 was the power value around the low frequency\nnewpower[312:]=p5power[312:512]\nax[2][1].plot(freq.reshape(-1,1), newpower)\nax[2][1].plot(freq[1:].reshape(-1,1)[10:312], predicted_power[10:312], color='red')\nax[2][1].axvline(x=freq[10], color='red', linestyle='--')\nax[2][1].axvline(x=freq[312], color='red', linestyle='--')\nax[2][1].set_xscale('log')\nax[2][1].set_yscale('log')\nax[2][1].set_xlabel(r\"Frequency ($f$)\")\nax[2][1].set_title(\"E but with a scaling range\", loc='left')\n\ntext = r\"$\\log_{10} \\left( \\frac{f_{max} - f_{min}}{f_s} \\right)$\"\ntext_xy = (freq[10]*1.7, 0.001)\nax[2][1].annotate(text, (freq[10],0.001), text_xy, arrowprops={\"arrowstyle\": \"->\", \"color\": \"red\"}, color=\"red\")\nax[2][1].annotate(text, (freq[312],0.001), text_xy, arrowprops={\"arrowstyle\": \"->\", \"color\": \"red\"}, color=\"red\")\n\nfor i in range(3):\n    ax[i, 0].text(-0.1, 1.1, string.ascii_uppercase[i], transform=ax[i, 0].transAxes, \n                  size=13, weight='bold')\n    ax[i, 1].text(-0.1, 1.1, string.ascii_uppercase[i+3], transform=ax[i, 1].transAxes, \n                  size=13, weight='bold')\n\nplt.savefig('../image/fourproperties.png', dpi=600, bbox_inches='tight', format='png')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![\n\n\n\n\n\n\n**Main properties of a fractal time-series** A-C show a raw time-series (fractional Gaussian noise in this example)\n\n\n\nat different scales: B is the first half of A (shown as vertical dashed lines in A), \n\n\n\nwhile C is half of B (shown in vertical dashed lines in B). D is a power spectral density plot of A. \n\n\n\nE shows D but on a log-log plot, demonstrating the linear nature of fractal signals when plotted on a log-log scale.\n\n\n\nThe slope of E is $-\\beta$. In this example, $\\beta$ is calculated to be 0.6, which translates to an H of 0.8.\n\n\n\nF shows a modified version of E, which imagines that E only demonstrates a power law scaling relationship \n\n\n\nbetween two distinct frequencies. The equation for calculating the scaling range in decades is shown.\n\n\n\nExact fractal time-series (A) was created using the Davies-Harte method.\n](Figures_files/figure-html/fig-fourprop-output-1.png){#fig-fourprop width=779 height=779}\n:::\n:::\n\n\n:::{#5614fc63 .cell .markdown}\n## Typical Sample Paths\n:::\n\n::: {#cell-fig-typicalsamplepaths .cell execution_count=5}\n``` {}\n#| label: fig-typicalsamplepaths\n#| fig-cap: |\n#| \n#| \n#| \n#|   **Simulated fractional Gaussian noise and fractional Brownian motion.** \n#| \n#|   Raw simulated time-series with 1,024 time-points and known Hurst values are plotted on the left. \n#| \n#|   The top three time-series are fractional Gaussian noise, while the bottom three are fractional Brownian motion. \n#| \n#|   H values are displayed on the left, while $\\beta$ values are displayed on the right.\n#| \n#|   Note how fractional Gaussian noise remain centered around a mean (i.e. stationary), \n#| \n#|   while fractional Brownian motion wanders away from the mean (i.e. non-stationary). \n#| \n#|   Log-log power spectral density plots of the signals on the left are shown on the right.\n#| \n#|   Linear-regression fits are shown in red, which are used to calculate $\\beta$ and H using\n#| \n#|   the appropriate equation (on the right).\n#| \n#|   Exact fractal time-series were created using the Davies-Harte method.\nnp.random.seed(1)\nplt.rcParams['text.usetex'] = True #latex\n\ndef psd(timeseries):\n    freq, power = signal.periodogram(timeseries, 1)\n    power = power[1:]\n    freq = freq[1:]\n\n    log_power = np.log10(power)\n    log_freq = np.log10(freq)\n    log_power = log_power[1:]\n    log_freq = log_freq[1:]\n\n    model = LinearRegression()\n    model.fit(log_freq.reshape(-1,1), log_power)\n    predicted_power = 10**model.predict(log_freq.reshape(-1,1))\n\n    return freq.reshape(-1,1), power, predicted_power\n\nfp5 = FBM(1024, hurst=0.5, length=1, method='daviesharte')\nfp1 = FBM(1024, hurst=0.1, length=1, method='daviesharte')\nfp9 = FBM(1024, hurst=0.9, length=1, method='daviesharte')\nfgnp5 = fp5.fgn()\nfgnp1 = fp1.fgn()\nfgnp9 = fp9.fgn()\nfbmp5 = fp5.fbm()\nfbmp1 = fp1.fbm()\nfbmp9 = fp9.fbm()\n\nfig, ax = plt.subplots(6,2, figsize=(10,7))\nfig.subplots_adjust(wspace=0.25)\nax[0,0].plot(fgnp1)\nax[0,0].set_title(\"Time Series\")\nax[0,0].xaxis.set_visible(False)\nax[0,0].set_ylabel(\"0.1\", rotation=0, labelpad=12)\nax[0,0].text(1.05, 0.55, \"-0.8\", rotation=0,\n             transform=ax[0,0].transAxes, color='red')\nax[0,0].set_yticks([])\nax[1,0].plot(fgnp5)\nax[1,0].xaxis.set_visible(False)\nax[1,0].set_yticks([])\nax[1,0].set_ylabel(\"0.5\", rotation=0, labelpad=12)\nax[1,0].text(1.08, 0.55, \"0\", rotation=0,\n             transform=ax[1,0].transAxes, color='red')\nax[2,0].plot(fgnp9)\nax[2,0].xaxis.set_visible(False)\nax[2,0].set_yticks([])\nax[2,0].set_ylabel(\"0.9\", rotation=0, labelpad=12)\nax[2,0].text(1.06, 0.55, \"0.8\", rotation=0,\n             transform=ax[2,0].transAxes, color='red')\nax[3,0].plot(fbmp1)\nax[3,0].xaxis.set_visible(False)\nax[3,0].set_yticks([])\nax[3,0].set_ylabel(\"0.1\", rotation=0, labelpad=12)\nax[3,0].text(1.06, 0.55, \"1.2\", rotation=0,\n             transform=ax[3,0].transAxes, color='red')\nax[4,0].plot(fbmp5)\nax[4,0].xaxis.set_visible(False)\nax[4,0].set_yticks([])\nax[4,0].set_ylabel(\"0.5\", rotation=0, labelpad=12)\nax[4,0].text(1.08, 0.55, \"2\", rotation=0,\n             transform=ax[4,0].transAxes, color='red')\nax[5,0].plot(fbmp9)\nax[5,0].set_yticks([])\nax[5,0].set_ylabel(\"0.9\", rotation=0, labelpad=12)\nax[5,0].set_xlabel(\"Time\")\nax[5,0].text(1.06, 0.55, \"2.8\", rotation=0,\n             transform=ax[5,0].transAxes, color='red')\n\nline = lines.Line2D([0.1, 1.05], [0.495, 0.495], transform=fig.transFigure, color='black', linewidth=1)\nfig.add_artist(line)\nfig.text(1, 0.705, r\"$H=\\frac{\\beta+1}{2}$\", ha='center', va='center', fontsize=18, transform=fig.transFigure)\nfig.text(1, 0.305, r\"$H=\\frac{\\beta-1}{2}$\", ha='center', va='center', fontsize=18, transform=fig.transFigure)\n\nfig.text(0.11, .9, r\"H\", fontsize=14, ha='center', va='center', transform=fig.transFigure)\nfig.text(0.5, .9, r\"$\\beta$\", fontsize=14, ha='center', va='center', transform=fig.transFigure, color='red')\n\nfreq,power,pred_power = psd(fgnp1)\nax[0,1].plot(freq,power)\nax[0,1].set_title(\"Power Spectral Density\")\nax[0,1].plot(freq[1:], pred_power, color='red')\nax[0,1].set_xscale('log')\nax[0,1].set_yscale('log')\nax[0,1].xaxis.set_visible(False)\nax[0,1].yaxis.tick_right()\nax[0,1].set_ylim(1e-4,10)\n\nfreq,power,pred_power = psd(fgnp5)\nax[1,1].plot(freq,power)\nax[1,1].plot(freq[1:], pred_power, color='red')\nax[1,1].set_xscale('log')\nax[1,1].set_yscale('log')\nax[1,1].xaxis.set_visible(False)\nax[1,1].yaxis.tick_right()\nax[1,1].set_ylabel(r\"$\\log|A(f)|^2$\")\nax[1,1].set_ylim(1e-5,1e-2)\n\nfreq,power,pred_power = psd(fgnp9)\nax[2,1].plot(freq,power)\nax[2,1].plot(freq[1:], pred_power, color='red')\nax[2,1].set_xscale('log')\nax[2,1].set_yscale('log')\nax[2,1].xaxis.set_visible(False)\nax[2,1].yaxis.tick_right()\nax[2,1].set_ylim(1e-9,1e-2)\n\nfreq,power,pred_power = psd(fbmp1)\nax[3,1].plot(freq,power)\nax[3,1].plot(freq[1:], pred_power, color='red')\nax[3,1].set_xscale('log')\nax[3,1].set_yscale('log')\nax[3,1].xaxis.set_visible(False)\nax[3,1].yaxis.tick_right()\n\nfreq,power,pred_power = psd(fbmp5)\nax[4,1].plot(freq,power)\nax[4,1].plot(freq[1:], pred_power, color='red')\nax[4,1].set_xscale('log')\nax[4,1].set_yscale('log')\nax[4,1].xaxis.set_visible(False)\nax[4,1].set_ylabel(r\"$\\log|A(f)|^2$\")\nax[4,1].yaxis.tick_right()\nax[4,1].set_ylim(1e-5,1e3)\n\nfreq,power,pred_power = psd(fbmp9)\nax[5,1].plot(freq,power)\nax[5,1].plot(freq[1:], pred_power, color='red')\nax[5,1].set_xscale('log')\nax[5,1].set_yscale('log')\n#ax[5,1].set_xticklabels([])\nax[5,1].yaxis.tick_right()\nax[5,1].set_xlabel(r\"$\\log(f)$\")\n\nplt.savefig('../image/typicalsamplepaths.png', dpi=600, bbox_inches='tight', format='png')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![\n\n\n\n\n\n\n**Simulated fractional Gaussian noise and fractional Brownian motion.** \n\n\n\nRaw simulated time-series with 1,024 time-points and known Hurst values are plotted on the left. \n\n\n\nThe top three time-series are fractional Gaussian noise, while the bottom three are fractional Brownian motion. \n\n\n\nH values are displayed on the left, while $\\beta$ values are displayed on the right.\n\n\n\nNote how fractional Gaussian noise remain centered around a mean (i.e. stationary), \n\n\n\nwhile fractional Brownian motion wanders away from the mean (i.e. non-stationary). \n\n\n\nLog-log power spectral density plots of the signals on the left are shown on the right.\n\n\n\nLinear-regression fits are shown in red, which are used to calculate $\\beta$ and H using\n\n\n\nthe appropriate equation (on the right).\n\n\n\nExact fractal time-series were created using the Davies-Harte method.\n](Figures_files/figure-html/fig-typicalsamplepaths-output-1.png){#fig-typicalsamplepaths width=932 height=598}\n:::\n:::\n\n\n::: {#bb307422 .cell execution_count=6}\n``` {}\nimport numpy as np\n\ndef spectral_synthesis_1d(N, H, seed=None):\n    \"\"\"\n    1D Spectral Synthesis Method for generating fractional Brownian motion\n    \n    Parameters:\n    N: Number of points in the time series\n    H: Hurst exponent\n    seed: Random seed for reproducibility\n    \"\"\"\n    # Set random seed if provided\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Initialize complex array for Fourier coefficients\n    A = np.zeros(N, dtype=complex)\n    \n    # Generate phases and radii\n    for i in range(N//2 + 1):\n        # Random phase\n        phase = 2 * np.pi * np.random.rand()\n        \n        # Radial component (skip origin)\n        if i != 0:\n            # Spectral density: power law decay\n            rad = np.power(i, -(H+1)) * np.random.randn()\n        else:\n            rad = 0\n        \n        # Assign complex Fourier coefficients\n        A[i] = rad * (np.cos(phase) + 1j * np.sin(phase))\n        \n        # Symmetric conjugate for negative frequencies\n        if i > 0 and i < N//2:\n            A[N-i] = rad * (np.cos(phase) - 1j * np.sin(phase))\n    \n    # Ensure the Nyquist frequency is real\n    A[N//2] = A[N//2].real\n    \n    # Inverse FFT to get time series\n    X = np.fft.irfft(A)\n    \n    return X\n\n# Example usage\nN = 1024  # Number of points\nH = 0.7   # Hurst exponent\ntime_series = spectral_synthesis_1d(N, H)\n```\n:::\n\n\n::: {#766f1c73 .cell execution_count=7}\n``` {}\n# this is adapted from The Science of Fractal Images, Springer-Verlag, 1988, page 108\n\ndef fractional_brownian_motion_1d(N, H, seed=None):\n    \"\"\"Generate a 1D fractional Brownian motion (fBm) using the spectral method.\"\"\"\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Frequency domain (Fourier space)\n    freqs = np.fft.rfftfreq(N)  # Only positive frequencies\n    S = np.zeros_like(freqs)\n    \n    # Power spectrum: S(f) ~ |f|^(-2H-1)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        S[1:] = freqs[1:] ** (-(2 * H + 1))\n    \n    S[0] = 0  # DC component should be zero to remove the mean drift\n    \n    # Generate Gaussian noise with correct magnitude\n    real_part = np.random.normal(0, np.sqrt(S / 2), len(S))\n    imag_part = np.random.normal(0, np.sqrt(S / 2), len(S))\n    imag_part[-1] = 0  # Ensure real-valued inverse FFT\n    F = real_part + 1j * imag_part\n\n    # Mirror frequencies for inverse FFT\n    F_full = np.concatenate([F, np.conj(F[-2:0:-1])])\n    \n    # Inverse FFT to obtain time-domain signal\n    fBm = np.fft.ifft(F_full).real\n    \n    # Normalize to unit variance\n    fBm -= fBm.min()\n    fBm /= fBm.max()\n    \n    return fBm\n\n# Parameters\nN = 1024  # Number of points\nH = 0.9   # Hurst parameter\nseed = 42  # Random seed for reproducibility\n\n# Generate and plot fBm\nfBm_signal = fractional_brownian_motion_1d(N, H, seed)\nplt.plot(fBm_signal, label=f'fBm (H={H})')\nplt.xlabel(\"Time\")\nplt.ylabel(\"Signal\")\nplt.title(\"1D Fractional Brownian Motion\")\nplt.legend()\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-8-output-1.png){width=583 height=446}\n:::\n:::\n\n\n::: {#03961f5f .cell execution_count=8}\n``` {}\ndef spectral_synthesis(N, H, seed=None):\n    \"\"\"\n    Spectral Synthesis Method for generating fractional Brownian motion\n    \n    Parameters:\n    N: Number of points in the time series\n    H: Hurst exponent\n    seed: Random seed for reproducibility\n    \"\"\"\n    # Set random seed if provided\n    if seed is not None:\n        np.random.seed(seed)\n    \n    # Calculate spectral slope\n    beta = 2 * H + 1\n    \n    # Initialize arrays for real and imaginary parts\n    A = np.zeros(N//2)\n    B = np.zeros(N//2)\n    \n    # Generate Fourier coefficients\n    for i in range(N//2):\n        # Radial component with power-law decay\n        rad = np.power(i+1, -beta/2) * np.random.randn()\n        \n        # Random phase\n        phase = 2 * np.pi * np.random.rand()\n        \n        # Real and imaginary components\n        A[i] = rad * np.cos(phase)\n        B[i] = rad * np.sin(phase)\n    \n    # Inverse FFT to get time series\n    # Combine real and imaginary parts\n    X = np.fft.irfft(A + 1j*B, n=N)\n    \n    return X\n\n# Example usage\nN = 1024  # Number of points\nH = 0.5   # Hurst exponent\ntime_series = spectral_synthesis(N, H)\n\n# Visualization\nplt.figure(figsize=(12,4))\nplt.plot(time_series)\nplt.title(f'Synthetic Time Series (H = {H})')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-9-output-1.png){width=962 height=356}\n:::\n:::\n\n\n::: {#ddf8817c .cell execution_count=9}\n``` {}\ndef tspowerplot(data):\n    fig, ax = plt.subplots(1,2, constrained_layout=True, figsize=(7,3))\n    ax[0].plot(data)\n    ax[0].set_title(\"a)\", loc='left')\n\n    freq, power = signal.periodogram(data, 1)\n    power = power[1:]\n    freq = freq[1:]\n\n    log_power = np.log10(power)\n    log_freq = np.log10(freq)\n    log_power = log_power[1:]\n    log_freq = log_freq[1:]\n\n    model = LinearRegression()\n    model.fit(log_freq.reshape(-1,1), log_power)\n    predicted_power = 10**model.predict(log_freq.reshape(-1,1))\n    beta = model.coef_*-1\n    if beta < 1:\n        Hurst = (beta+1)/2\n    else:\n        Hurst = (beta-1)/2\n\n    ax[1].plot(freq.reshape(-1,1), power)\n    ax[1].set_xscale('log')\n    ax[1].set_yscale('log')\n    ax[1].plot(freq[1:].reshape(-1,1), predicted_power, color='red')\n    ax[1].set_title(\"b)\", loc='left')\n\n    fig.suptitle(f\"Real Hurst: {H}\\nSlope (m): {round(float(model.coef_),3)}; Estimated Hurst: {round(float(Hurst),2)}\")\n\ntspowerplot(fBm_signal)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-10-output-1.png){width=683 height=299}\n:::\n:::\n\n\n::: {#477d9985 .cell execution_count=10}\n``` {}\ntspowerplot(time_series)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-11-output-1.png){width=683 height=299}\n:::\n:::\n\n\n::: {#2aa002b7 .cell execution_count=11}\n``` {}\nfrom scipy.stats import binom\nfrom scipy.fftpack import fft\nimport statsmodels.api as sm\nfrom stochastic.processes.noise import FractionalGaussianNoise as fgn\nfrom stochastic.processes.continuous import FractionalBrownianMotion as fbm\n%matplotlib inline\n\ndef linreg_weber(x, y, **kwargs):\n    # performs linear regression (OLS) and returns slope, R, residuals and predicted y values\n    \n    # Set default min and max values for x\n    xMin = np.min(x)\n    xMax = np.max(x)\n\n    # Handle optional xmin and xmax (here expected frequencies)\n    # The below looks weird, as xMin = max and xMax = min, but it is just ensuring that the xmin and xmax you give are actually larger and smaller (respectively) than the absolute min and max\n    if 'freqmin' in kwargs:\n        xMin = max(xMin, kwargs['freqmin'])\n    if 'freqmax' in kwargs:\n        xMax = min(xMax, kwargs['freqmax'])\n\n    # Get indices for the specified xMin and xMax range\n    xMinInd = np.where(x >= xMin)[0][0] # will return an array of all values larger or equal then min, and pick the first\n    xMaxInd = np.where(x <= xMax)[0][-1] # will return an array of all values smaller or equal then max, and pick the last\n\n    # Slice x and y arrays to focus on the relevant range\n    x_range = x[xMinInd:xMaxInd + 1]\n    y_range = y[xMinInd:xMaxInd + 1] # note, I have tested this and it is correct\n\n    # Perform linear regression\n    X = sm.add_constant(x_range)  # Add constant (intercept)\n    model = sm.OLS(y_range, X).fit() # Ordinary Least Squares\n\n    # Calculate correlation coefficient (R value)\n    R = np.corrcoef(x_range, y_range)[0, 1]\n\n    # Get the slope from the model coefficients\n    slope = model.params[1]\n\n    # Calculate residuals (errors)\n    residuals = model.resid\n\n    # Fitted values (predicted y values)\n    y_fitted = model.fittedvalues\n\n    return slope, R, residuals, y_fitted\ndef spec_weber(ts, sf):\n    L = len(ts) # length of time-series\n    \n    # Perform FFT\n    Y = fft(ts) # fast fourier\n    Pyy = np.abs(Y) ** 2 / L # square of absolute divided by length\n    power = Pyy[:L // 2]  # Keep first half of spectrum\n\n    freq = sf / L * np.arange(1, L // 2 + 1) # Create frequencies from sampling rate (sf)\n\n    # Perform log transformation\n    lgPyy = np.log(power)\n    lgfreq = np.log(freq)\n\n    # Perform linear regression on log-log data\n    slope, R, residuals, y_fitted = linreg_weber(lgfreq, lgPyy)\n\n    if -slope < 1:  # fGn case\n        Hurst = (-slope + 1) / 2\n    elif -slope > 1:  # fBm case\n        Hurst = (-slope - 1) / 2\n    elif -slope == 1:  # Unknown case\n        Hurst = 0 # might as well, not sure what else to set it to: Nan? Inf?\n    return freq, power, Hurst, slope, R, residuals, y_fitted\ndef Bridge(ts):\n    '''This function bridge detrends the signal input ts\n    The function subtracts a line connecting the first and last points from the signal'''\n    n = len(ts)\n    #points is the length of the time series from n-1 to 0 (backwards i.e. n-1, n-2,...0)\n    points = np.arange(n-1, -1, -1).reshape(1,n)\n    #line is a straight line connecting first and last point\n    line = ((ts[0]-ts[n-1])*points/(n-1))+ts[n-1]\n    line = line.transpose() #transposes line from row to column array\n    #subtract line from time series to return bridge detrended signal (result)\n    result = ts - np.transpose(line)\n    return result \ndef Window(ts):\n    '''This function applies a parabolic window to the signal input'''\n    n = len(ts) #n is length of time series\n    W = np.zeros(n) #initialize empty array\n    #create parabola from 0 to length n\n    for j in np.arange(n):\n        W[j] = 1 - np.power((2*(j + 1)/(n+1)-1),2)\n    #multiply parabola and signal to get windowed signal (result)\n    result = ts * W \n    return result\n\ndef pfgncalc_weber(logfreq, logpower, sf, hurst, ftype, Nsize, **kwargs):\n    # Default parameters\n    logfreqmin = np.min(logfreq)\n    logfreqmax = np.max(logfreq)\n    nSamples = 500\n    pCrit = 0.05\n    likelihood = 1e-3 #f there's less than a 0.1% chance that continuing the simulations would change whether p exceeds pCrit, the function terminates early\n\n    # Handle optional parameters\n    for key, value in kwargs.items():\n        if key == 'freqmin':\n            logfreqmin = value\n        elif key == 'freqmax':\n            logfreqmax = value\n        elif key == 'samples':\n            nSamples = value\n        elif key == 'threshold':\n            pCrit = value\n        elif key == 'likelihood':\n            likelihood = value\n\n    # Calculate the Kolmogorov-Smirnov statistic for the empirical data\n    _, _, residuals, _ = linreg_weber(logfreq, logpower, freqmin=logfreqmin, freqmax=logfreqmax)\n\n    empiricalKS = np.max(np.abs(residuals))\n\n    # Store Kolmogorov-Smirnov statistic\n    ks = [empiricalKS, np.zeros(nSamples)]\n\n    # Compute p-value\n    successCounts = np.zeros(nSamples)\n    nSuccesses = 0\n    thisLikelihood = 1\n    binomialFlag = True\n    criticalThreshold = nSamples * pCrit\n\n    samplebeta = np.zeros(nSamples)\n\n    for iSample in range(nSamples):\n        if thisLikelihood <= likelihood or not binomialFlag:\n            break\n\n        if ftype == 1:\n            # Generate sample data based on Hurst\n            #fgnsample = fgn(fsd, hurst, 1, Nsize, 0)\n            fgnsample = fgn(hurst=hurst, t=1)\n            fsample = fgnsample.sample(Nsize)\n        elif ftype == 2:\n            fbmsample = fbm(hurst=hurst, t=1)\n            fsample = fbmsample.sample(Nsize)\n\n        # Calculate power spectrum for the sample data\n        _, powersample, _, _, _, _, _ = spec_weber(fsample, sf)\n        logpowersample = np.log(powersample)\n\n        # Perform linear regression on log-log data of sample\n        thisbeta, _, theseresiduals, _ = linreg_weber(logfreq, logpowersample, freqmin=logfreqmin, freqmax=logfreqmax)\n\n        if pCrit == 1:\n            samplebeta[iSample] = -thisbeta\n\n        # Calculate the KS statistic for simulated data\n        sampleKS = np.max(np.abs(theseresiduals))\n\n        # Store sample KS\n        ks[1][iSample] = sampleKS\n\n        # Record a success if the empirical KS is bounded above by the sample KS\n        if empiricalKS <= sampleKS:\n            successCounts[iSample] = 1\n            nSuccesses += 1\n\n        # Stop if success count reaches critical threshold\n        if nSuccesses == criticalThreshold:\n            binomialFlag = False\n\n        # Update likelihood if pCrit != 1\n        if pCrit != 1:\n            thisLikelihood = 1 - binom.cdf(criticalThreshold - nSuccesses - 1, nSamples - iSample, pCrit)\n\n    # Calculate p-value\n    p = np.sum(successCounts) / nSamples\n\n    # Compute standard deviation of beta if enough samples were processed\n    if iSample == nSamples:\n        sigmabeta = np.std(samplebeta)\n    else:\n        sigmabeta = np.nan\n\n    return p, ks, sigmabeta\n\ndef plparams_weber(timeseries, samplingfreq, **kwargs):\n\n    # If all values in the time-series are the same, end the program and return all zeroes\n    if np.unique(timeseries).size == 1:\n        Hurst, ftype, beta, freqmin, freqmax, sigmabeta, p, pCrit, ks = 0, 0, 0, 0, 0, 0, 0, 0, 0\n        print(\"Timeseries values are all the same. Returning all measures as 0\")\n        return Hurst, ftype, beta, freqmin, freqmax, sigmabeta, p, pCrit, ks\n\n    #default parameters\n    nSamples=500\n    #pCrit=0.2\n    pCrit=0.05\n    likelihood=1e-3\n    finalplotFlag=False\n    saveintermplotsFlag=False\n    \n    # Handle optional parameters\n    for key, value in kwargs.items():\n        if key == 'nSamples':\n            nSamples = value\n        elif key == 'pCrit':\n            pCrit = value\n        elif key == 'likelihood':\n            likelihood = value\n        elif key == 'finalplot':\n            finalplotFlag = True\n        elif key == 'saveintermplots':\n            saveintermplotsFlag = True\n    \n    Nsize = len(timeseries)\n\n    ### Hopefully this removes any scanner drift without really affecting the signal or the signal categorization\n    timeseries = np.squeeze(Bridge(Window(signal.detrend(timeseries)))) # Bridge detrend (won't affect if it is already performed) and reduce dimensions\n\n    freq, power, _, _, _, _, _ = spec_weber(timeseries, samplingfreq)\n\n    # Find combinations of freqmin and freqmax that are two decades apart\n    n = len(freq)\n    combinations = []\n\n    for i in range(n):\n        highfreqs = np.where(freq >= 100 * freq[i])[0]\n        for j in highfreqs:\n            combinations.append([freq[i], freq[j]])\n\n    combinations = np.array(combinations)\n\n    idx = np.argsort(-combinations[:, 1])  # Negate for descending sort\n\n    # Rearrange the combinations using the sorted indices\n    combinations = combinations[idx]\n    temp = combinations[0].copy()  # Copy to prevent unintended reference issues\n    combinations[0] = combinations[1]\n    combinations[1] = temp\n\n    # Initiate greedy search for optimal support\n    sweepFlag = True\n    icombination = 0\n    ncombinations = len(combinations)\n\n    while sweepFlag and icombination < ncombinations:\n        freqmin, freqmax = combinations[icombination]\n        print(f\"Current support pair is {icombination + 1} of {ncombinations}: {freqmin} to {freqmax}\")\n\n        log_freq = np.log(freq)\n        log_power = np.log(power)\n        beta, R, _, fittedvalues = linreg_weber(log_freq, log_power, freqmin=np.log(freqmin), freqmax=np.log(freqmax))\n        print(f\"R is {R}\")\n        beta = -beta\n        print(f\"beta is {beta}\")\n\n        if 0 <= beta < 1:\n            print(\"Beta is between 0 and 1. Signal is estimated to be fGn\")\n            Hurst = (beta + 1) / 2\n            ftype = 1\n        elif beta > 1:\n            print(\"Beta is greater than 1. Signal is estimated to be fBm\")\n            Hurst = (beta - 1) / 2\n            ftype = 2\n        else:\n            print(\"Signal is unknown\")\n            Hurst = 0 # might as well, not sure what else to set it to. Nan?\n            ftype = 0\n            saveintermplotsFlag = False\n\n       # if saveintermplotsFlag:\n\n        if Hurst == 0:\n            print(\"Hurst can not be defined. Ending program\")\n            return 0, 0, 0, 0, 0, 0, 0, 0, 0\n        else:\n            print(f\"Hurst is estimated to be {Hurst}\")\n\n        p, _, _ = pfgncalc_weber(log_freq, log_power, samplingfreq, Hurst, ftype, Nsize, freqmin=np.log(freqmin), freqmax=np.log(freqmax), nSamples=nSamples, pCrit=pCrit, likelihood=likelihood)\n        print(f\"The p-value was found to be: {p}\")\n\n        if p >= pCrit:\n            sweepFlag = False\n        else:\n            icombination += 1\n\n    #print(\"Calculating final p, ks and sigmabeta\")\n    p, ks, sigmabeta = pfgncalc_weber(log_freq, log_power, samplingfreq, Hurst, ftype, Nsize, freqmin=np.log(freqmin), freqmax=np.log(freqmax), nSamples=nSamples, pCrit=pCrit, likelihood=likelihood)\n    #print(f\"min and max freq were found to be: {freqmin} and {freqmax}\")\n    if p >= pCrit:\n        print(f\"\"\"\n        final Hurst and ftype were found to be: {round(Hurst,2)} and {ftype}\\\\\n        where 1 = fGn; and 2 = fBm\\\\\n        final fmin and fmax are: {freqmin} and {freqmax}, respectively\n        \"\"\")\n    else:\n        print(\"Hurst can not be defined. Ending program\")\n\n    if finalplotFlag:\n        plt.figure()\n        plt.scatter(freq, power, color='red', s=20)\n        plt.plot(freq[(freq >= freqmin) & (freq <= freqmax)], np.exp(fittedvalues), 'k')\n        plt.xscale('log')\n        plt.yscale('log')\n        plt.xlabel('logfreq')\n        plt.ylabel('logpower')\n        plt.title('loglog Power Frequency')\n        plt.grid(True)\n        plt.show()\n\n\n    return Hurst, ftype, beta, freqmin, freqmax, sigmabeta, p, pCrit, ks\n```\n:::\n\n\n::: {#889bf255 .cell execution_count=12}\n``` {}\n#time_series = spectral_synthesis(1024, 0.9)\nhurst=0.7\nNsize=1024\nfbmtestsample = fbm(hurst=hurst, t=1)\nfbmtestsample = fbmtestsample.sample(Nsize)\nHurst, ftype, beta, freqmin, freqmax, sigmabeta, p, pCrit, ks = plparams_weber(time_series,1,finalplot=True)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCurrent support pair is 1 of 1065: 0.0009765625 to 0.5\nR is -0.7724983821681904\nbeta is 1.9371675748909232\nBeta is greater than 1. Signal is estimated to be fBm\nHurst is estimated to be 0.4685837874454616\nThe p-value was found to be: 0.05\n\n        final Hurst and ftype were found to be: 0.47 and 2\\\n        where 1 = fGn; and 2 = fBm\\\n        final fmin and fmax are: 0.0009765625 and 0.5, respectively\n        \n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-13-output-2.png){width=599 height=446}\n:::\n:::\n\n\n::: {#c66ccec1 .cell execution_count=13}\n``` {}\nfrom scipy.signal import lfilter\nfrom scipy import signal\n\ntest_signals = {\n    \"Sinusoid\": np.sin(2 * np.pi * 5 * np.linspace(0, 10, Nsize)),\n}\n\nfor name, signals in test_signals.items():\n    print(f\"\\nTesting: {name}\")\n    try:\n        results = plparams_weber(signals, 1, finalplot=True)\n        print(f\"Results: {results}\")\n    except ValueError as e:\n        print(f\"Failed as expected: {e}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nTesting: Sinusoid\nCurrent support pair is 1 of 1065: 0.0009765625 to 0.5\nR is -0.6371294814521082\nbeta is 3.501269439031046\nBeta is greater than 1. Signal is estimated to be fBm\nHurst is estimated to be 1.250634719515523\nFailed as expected: Hurst value must be in interval (0,1).\n```\n:::\n:::\n\n\n::: {#d603f688 .cell execution_count=14}\n``` {}\nfrom scipy.signal import butter, filtfilt\ndef bandpass_filter(signal, fs, lowcut, highcut, order=5):\n    \"\"\"Applies a bandpass filter to retain only the desired frequency range.\"\"\"\n    nyq = 0.5 * fs\n    low, high = lowcut / nyq, highcut / nyq\n    b, a = butter(order, [low, high], btype='band')\n    return filtfilt(b, a, signal)\n\n# Parameters\nN = 1024  # Number of points\nfs = 1    # Sampling frequency\nhurst = 0.7  # Hurst parameter for scaling range\n\n# 1. Generate scale-invariant (power-law) noise in the middle range\nfbm_signal = fbm(hurst=hurst, t=1)\nfbm_signal = fbm_signal.sample(Nsize)\n\n# 2. Add white noise at high frequencies\nwhite_noise = np.random.normal(0, 1, N)\n\n# 3. Add low-frequency drift (trend)\nlow_freq_trend = np.cumsum(np.random.normal(0, 0.05, N))\n\n# 4. Apply bandpass filter to isolate power-law scaling in a frequency band\nfiltered_fbm = bandpass_filter(fbm_signal, fs, lowcut=0.05, highcut=0.3)\n\n# 5. Combine all components\ntest_signal = filtered_fbm[1:] + white_noise + low_freq_trend\n\n# Plot the result\nplt.figure(figsize=(10, 4))\nplt.plot(test_signal, label=\"Mixed Scaling Signal\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-15-output-1.png){width=790 height=336}\n:::\n:::\n\n\n::: {#cc2c744d .cell execution_count=15}\n``` {}\nresults = plparams_weber(test_signal, 1, finalplot=True)\nprint(f\"Results: {results}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCurrent support pair is 1 of 1065: 0.0009765625 to 0.5\nR is -0.11381345111733288\nbeta is 0.15340742922665826\nBeta is between 0 and 1. Signal is estimated to be fGn\nHurst is estimated to be 0.5767037146133291\nThe p-value was found to be: 0.05\n\n        final Hurst and ftype were found to be: 0.58 and 1\\\n        where 1 = fGn; and 2 = fBm\\\n        final fmin and fmax are: 0.0009765625 and 0.5, respectively\n        \n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](Figures_files/figure-html/cell-16-output-2.png){width=593 height=446}\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nResults: (0.5767037146133291, 1, 0.15340742922665826, 0.0009765625, 0.5, nan, 0.05, 0.05, [6.007428208148862, array([ 5.38167866,  6.69347939,  4.72560676,  8.75693474,  4.92627965,\n        6.36016924,  6.87468902,  6.32879932,  6.46663785,  6.36454574,\n        5.65745283,  5.03225316,  7.66319746,  5.48983863,  7.84673531,\n        4.61992615,  7.06787978,  5.91023999,  5.38143885,  6.91984916,\n        5.65092485,  6.84597526,  5.87948591,  6.77976816,  6.59352849,\n        5.35780811,  5.03338013,  6.52601572,  6.20165545,  4.43148986,\n        6.96273533,  7.44830715,  5.50935151,  5.89908938,  5.81038756,\n        6.29112913,  6.63551131,  5.04591188,  5.77697718,  5.57856922,\n        5.80255418,  6.5544617 ,  6.24874542,  6.36286605,  6.50282012,\n        5.95401186, 21.44466719,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ,\n        0.        ,  0.        ,  0.        ,  0.        ,  0.        ])])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "Figures_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}